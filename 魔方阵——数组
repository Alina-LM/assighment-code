#include <stdio.h>
int main( )
{
    int a[17][17],i,j,k,p,n;  // 定义大一点的数组，避免越界
    p=1;
    while(p==1)
    {
        printf("enter n(n=1--15):");
        scanf("%d",&n);
        if ((n!=0) && (n<=15) && (n%2!=0))
            p=0;  // 输入合法，退出循环
    }

    // 初始化数组为0（使用1~n的下标，预留边界）
    for (i=1;i<=n;i++)
        for (j=1;j<=n;j++)
            a[i][j]=0;

    // 建立魔方阵
    i=1;           // 初始化i为第一行
    j=n/2+1;       // 中间列
    a[i][j]=1;     // 放置1

    // 从2到n*n依次放置
    for (k=2;k<=n*n;k++)
    {
        // 保存当前位置，用于回溯
        int old_i = i;
        int old_j = j;
        
        // 先尝试向右上移动（行减1，列加1）
        i=i-1;
        j=j+1;

        // 情况1：同时超出上边界和右边界
        if ((i<1) && (j>n))
        {
            i=old_i+1;  // 放在原位置的正下方
            j=old_j;    // 列不变
        }
        // 情况2：只超出上边界
        else if (i<1)
        {
            i=n;    // 跳到最后一行
        }
        // 情况3：只超出右边界  
        else if (j>n)
        {
            j=1;    // 跳到第一列
        }

        // 检查目标位置是否已被占用
        if (a[i][j]==0)
        {
            // 位置为空，直接放置
            a[i][j]=k;
        }
        else
        {
            // 位置已被占用，放在原数字的正下方
            i=old_i+1;  // 原位置的正下方
            j=old_j;    // 列不变
            a[i][j]=k;
        }
    }

    // 输出魔方阵
    for (i=1;i<=n;i++)
    {
        for (j=1;j<=n;j++)
            printf("%5d",a[i][j]);
        printf("\\n");
    }

    return 0;
}
